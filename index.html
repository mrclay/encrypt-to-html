<!DOCTYPE html>
<html lang="en">

<head>
  <script type="encrypted" data-el="store">null</script>

  <meta charset="utf-8" />
  <title>Encrypt to HTML</title>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css"
    integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous" />

  <style>
    textarea {
      font-family: monospace;
      white-space: pre-wrap;
      width: 90%;
      height: 10em;
    }

    [hidden] {
      display: none !important;
    }

    body {
      margin: 2em 0;
    }

    header {
      margin: 0 2em 2em;
    }

    section {
      margin: 0 2em;
    }

    footer {
      margin-top: 2em;
      padding: 1em 2em 0 2em;
      border-top: 1px solid #ccc;
    }

    textarea {
      font-family: monospace;
    }

    input[data-el="file"] {
      display: inline-block;
    }

    #file_base {
      width: 10em;
      display: inline-block;
      vertical-align: middle;
    }

    [for="pwd1"] small {
      font-style: italic;
    }

    [type="submit"] img {
      height: 1em;
      margin-left: 5px;
    }
  </style>
</head>

<body>
  <header>
    <h1 class="text-muted">Encrypt to HTML</h1>
    <p>
      This outputs a standalone HTML file that can be decrypted
      <em>anywhere</em>, even offline.
    </p>
    <p>
      100% client-side.
      <a href="" download="encrypt-to-html.html">Download</a> and use it
      anywhere.
    </p>
  </header>

  <section data-el="encrypt">
    <div class="form-group">
      <label for="msg">Sensitive Content</label> ...or <input type="file" data-el="file" />
      <textarea class="form-control" rows="5" id="msg" autofocus data-el="in" required></textarea>
    </div>
    <div class="form-group">
      <label for="pwd1">Password (repeat) <small>Use a strong one!</small></label>
      <input type="password" data-el="pwd1" class="form-control" id="pwd1" required autocomplete="off" />
      <input type="password" data-el="pwd2" class="form-control" id="pwd2" required autocomplete="off" />
    </div>
    <div class="form-group">
      <label for="file_base">Filename</label>
      <input class="form-control" type="text" data-el="name" id="file_base" value="my-secret" required />
      .html
    </div>
    <button data-el="encryptBtn" class="btn btn-primary">Encrypt</button>
  </section>

  <section data-el="decrypt">
    <div class="form-group">
      <label for="pwd">Password</label>
      <input type="password" data-el="pwd" class="form-control" id="pwd" required autocomplete="off" />
    </div>

    <p>
      <button data-el="decryptBtn" class="btn btn-primary">Decrypt</button>
    </p>

    <div class="form-group" data-el="outWrapper">
      <label for="msg_out">Stored Content</label>
      <textarea class="form-control" rows="10" id="msg_out" autofocus data-el="out" readonly></textarea>
    </div>

    <div>
      <p><button data-el="reset" class="btn btn-primary">Encrypt something new</button></p>
    </div>
  </section>

  <footer>
    <p>
      By <a href="http://www.mrclay.org/">Steve Clay</a>.
      <a href="https://github.com/mrclay/encrypt-to-html">Source</a>.
      Uses WebCrypto (256-bit AES-GCM, PBKDF2 key generation with at least 500K rounds). Version 2.0.
    </p>
    <p>
      Dig it? Send me something on my
      <a href="https://www.amazon.com/hz/wishlist/ls/2QG3N5JPO53BD?ref_=wl_share">wish list</a>.
    </p>
  </footer>

  <script>
    (async () => {
      const getKeyMaterial = (password) =>
        crypto.subtle.importKey(
          "raw",
          new TextEncoder().encode(password),
          "PBKDF2",
          false,
          ["deriveBits", "deriveKey"]
        );

      async function decrypt(
        password,
        iterations,
        salt,
        iv,
        encryptedBuffer
      ) {
        const keyMaterial = await getKeyMaterial(password);
        const key = await crypto.subtle.deriveKey(
          { name: "PBKDF2", salt, iterations, hash: "SHA-256" },
          keyMaterial,
          { name: "AES-GCM", length: 256 },
          true,
          ["encrypt", "decrypt"]
        );

        return crypto.subtle
          .decrypt({ name: "AES-GCM", iv }, key, encryptedBuffer);
      }

      async function encrypt(password, plaintext) {
        const iv = crypto.getRandomValues(new Uint8Array(16));
        const salt = crypto.getRandomValues(new Uint8Array(16));

        let keyMaterial = await getKeyMaterial(password);
        let iterations = 5000000;
        let key;

        for (let i = 0; i < 20; i++) {
          const startTime = performance.now();

          key = await crypto.subtle.deriveKey(
            { name: "PBKDF2", salt, iterations, hash: "SHA-256" },
            keyMaterial,
            { name: "AES-GCM", length: 256 },
            true,
            ["encrypt", "decrypt"]
          );

          if (performance.now() - startTime > 500) {
            break;
          }

          iterations = Math.round(iterations * 1.5);
        }

        const encryptedBuffer = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv },
          key,
          plaintext
        );

        return {
          encryptedBuffer,
          iterations,
          salt,
          iv,
        };
      }

      const base64FromBuffer = (buffer) =>
        btoa(
          new Uint8Array(buffer).reduce(
            (data, byte) => data + String.fromCharCode(byte),
            ""
          )
        );

      const bufferFromBase64 = (base64) => {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }

        return bytes.buffer;
      };

      function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.style.display = "none";
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(url);
      }

      document.addEventListener("DOMContentLoaded", () => {
        const els = {};
        document.querySelectorAll("[data-el]").forEach((el) => {
          els[el.dataset.el] = el;
        });

        setInterval(function () {
          if (els.in.scrollHeight > els.in.offsetHeight + 10) {
            els.in.style.height = (els.in.scrollHeight + 10) + 'px';
          }
        }, 1000);

        els.file.addEventListener("change", function () {
          els.in.hidden = true;
          els.name.value = els.file.files[0].name;
        });

        const storedData = JSON.parse(els.store.textContent);

        if (storedData) {
          els.encrypt.hidden = true;
          els.decrypt.hidden = false;
          els.outWrapper.hidden = true;
          els.reset.hidden = true;
        } else {
          els.encrypt.hidden = false;
          els.decrypt.hidden = true;
        }

        els.name.addEventListener("focus", () => {
          if (els.name.value === "my-secret") {
            els.name.select();
          }
        });

        let working = false;
        els.encryptBtn.addEventListener("click", async (e) => {
          if (working) {
            return;
          }

          if (els.pwd1.value !== els.pwd2.value) {
            alert("Passwords do not match");
            return;
          }

          if (els.pwd1.value.lenth < 6) {
            alert("Password less than 6 characters");
            return;
          }

          // Encryption
          const files = els.file.files;

          working = true;
          els.encryptBtn.textContent = "⏳ Working...";
          els.encryptBtn.style.opacity = ".6";

          function stop() {
            working = false;
            els.encryptBtn.textContent = "Encrypt";
            els.encryptBtn.style.opacity = "";
          }

          let plaintext = (new TextEncoder()).encode(els.in.value);
          if (files[0]) {
            plaintext = await new Promise(res => {
              reader = new FileReader();
              reader.onload = (e) => res(e.target.result);
              reader.readAsArrayBuffer(files[0]);
            });
          }

          encrypt(els.pwd1.value, plaintext).then((res) => {
            stop();

            const filename = files.length ? files[0].name : "";

            const { iterations, salt, iv, encryptedBuffer } = res;

            const encryptData = [
              filename,
              iterations,
              base64FromBuffer(salt),
              base64FromBuffer(iv),
              base64FromBuffer(encryptedBuffer),
            ];

            els.store.textContent = JSON.stringify(encryptData);
            document.querySelectorAll("[hidden]").forEach(el => el.removeAttribute("hidden"));

            // Capture HTML
            const blob = new Blob(
              ["<!DOCTYPE html>", document.querySelector('html').outerHTML],
              { type: "text/html" }
            );

            els.decrypt.hidden = true;

            downloadBlob(blob, els.name.value + ".html");
          });
        });

        els.pwd.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            els.decryptBtn.click();
          }
        });

        els.decryptBtn.addEventListener("click", () => {
          if (working) {
            return;
          }

          const [filename, iterations, strSalt, strIv, strEncrypted] = storedData;

          working = true;
          els.decryptBtn.textContent = "⏳ Working...";
          els.decryptBtn.style.opacity = ".6";

          function stop() {
            working = false;
            els.decryptBtn.textContent = "Decrypt";
            els.decryptBtn.style.opacity = "";
          }

          const salt = bufferFromBase64(strSalt);
          const iv = bufferFromBase64(strIv);
          const encryptedBuffer = bufferFromBase64(strEncrypted);

          decrypt(els.pwd.value, iterations, salt, iv, encryptedBuffer)
            .then((decryptedBuffer) => {
              stop();
              if (filename) {
                const blob = new Blob([decryptedBuffer]);
                downloadBlob(blob, filename);
              } else {
                const decrypted = (new TextDecoder()).decode(decryptedBuffer);
                els.out.value = decrypted;
                els.outWrapper.hidden = false;
              }

              els.reset.hidden = false;
            })
            .catch((e) => {
              stop();
              alert(String(e));
            });
        });

        els.pwd2.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            els.encryptBtn.click();
          }
        });

        els.reset.addEventListener("click", () => {
          // Encrypt something new with same password
          els.out.hidden = true;
          els.in.value = els.out.value;
          els.out.value = "";
          els.pwd1.value = els.pwd.value;
          els.pwd2.value = els.pwd.value;
          els.encrypt.hidden = false;
          els.decrypt.hidden = true;
        });
      });
    })();
  </script>
</body>

</html>
